# 🌲 树问题完整列表

## 📈 统计信息
- **总题目数**: ~450题
- **Easy**: ~100题
- **Medium**: ~250题  
- **Hard**: ~100题
- **高频面试题**: ~120题

## 🎯 核心知识点
- 二叉树遍历 (前序、中序、后序、层序)
- 二叉搜索树 (BST性质与操作)
- 树的构造与重建
- 最近公共祖先 (LCA)
- 树形动态规划
- 树的路径问题
- N叉树处理

---

## 📚 分类题目列表

### 🔰 树基础操作 (Easy-Medium 120题)

#### 基础遍历类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 94 | Binary Tree Inorder Traversal | Easy | ⭐⭐⭐ | 中序遍历 |
| 144 | Binary Tree Preorder Traversal | Easy | ⭐⭐⭐ | 前序遍历 |
| 145 | Binary Tree Postorder Traversal | Easy | ⭐⭐⭐ | 后序遍历 |
| 102 | Binary Tree Level Order Traversal | Medium | ⭐⭐⭐ | 层序遍历 |
| 103 | Binary Tree Zigzag Level Order Traversal | Medium | ⭐⭐ | 锯齿遍历 |
| 107 | Binary Tree Level Order Traversal II | Medium | ⭐⭐ | 自底向上层序 |
| 199 | Binary Tree Right Side View | Medium | ⭐⭐⭐ | 右视图 |
| 515 | Find Largest Value in Each Tree Row | Medium | ⭐ | 层序最大值 |
| 637 | Average of Levels in Binary Tree | Easy | ⭐ | 层级平均值 |
| 429 | N-ary Tree Level Order Traversal | Medium | ⭐ | N叉树层序 |
| 589 | N-ary Tree Preorder Traversal | Easy | ⭐ | N叉树前序 |
| 590 | N-ary Tree Postorder Traversal | Easy | ⭐ | N叉树后序 |
| 987 | Vertical Order Traversal of a Binary Tree | Hard | ⭐⭐ | 垂直遍历 |
| 314 | Binary Tree Vertical Order Traversal | Medium | ⭐⭐ | 垂直遍历 |
| 1302 | Deepest Leaves Sum | Medium | ⭐ | 最深叶子和 |

#### 树的性质判断类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 100 | Same Tree | Easy | ⭐⭐⭐ | 树比较 |
| 101 | Symmetric Tree | Easy | ⭐⭐⭐ | 对称树 |
| 104 | Maximum Depth of Binary Tree | Easy | ⭐⭐⭐ | 树深度 |
| 111 | Minimum Depth of Binary Tree | Easy | ⭐⭐ | 最小深度 |
| 110 | Balanced Binary Tree | Easy | ⭐⭐⭐ | 平衡树 |
| 226 | Invert Binary Tree | Easy | ⭐⭐⭐ | 翻转树 |
| 543 | Diameter of Binary Tree | Easy | ⭐⭐⭐ | 树直径 |
| 572 | Subtree of Another Tree | Easy | ⭐⭐ | 子树判断 |
| 965 | Univalued Binary Tree | Easy | ⭐ | 单值树 |
| 617 | Merge Two Binary Trees | Easy | ⭐⭐ | 合并树 |
| 951 | Flip Equivalent Binary Trees | Medium | ⭐ | 翻转等价 |
| 958 | Check Completeness of a Binary Tree | Medium | ⭐⭐ | 完全树 |
| 979 | Distribute Coins in Binary Tree | Medium | ⭐⭐ | 分发硬币 |
| 1008 | Construct Binary Search Tree from Preorder | Medium | ⭐ | BST构造 |
| 1325 | Delete Leaves With a Given Value | Medium | ⭐ | 删除叶子 |

#### 路径问题类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 112 | Path Sum | Easy | ⭐⭐⭐ | 路径和 |
| 113 | Path Sum II | Medium | ⭐⭐⭐ | 路径和II |
| 437 | Path Sum III | Medium | ⭐⭐⭐ | 路径和III |
| 124 | Binary Tree Maximum Path Sum | Hard | ⭐⭐⭐ | 最大路径和 |
| 129 | Sum Root to Leaf Numbers | Medium | ⭐⭐ | 根到叶数字和 |
| 257 | Binary Tree Paths | Easy | ⭐⭐ | 所有路径 |
| 988 | Smallest String Starting From Leaf | Medium | ⭐ | 最小字符串 |
| 1022 | Sum of Root To Leaf Binary Numbers | Easy | ⭐ | 二进制路径和 |
| 1457 | Pseudo-Palindromic Paths | Medium | ⭐ | 伪回文路径 |
| 666 | Path Sum IV | Medium | ⭐ | 路径和IV |
| 687 | Longest Univalue Path | Medium | ⭐ | 最长同值路径 |
| 1123 | Lowest Common Ancestor of Deepest Leaves | Medium | ⭐ | 最深叶子LCA |
| 1372 | Longest ZigZag Path in a Binary Tree | Medium | ⭐ | 最长锯齿路径 |
| 1430 | Check If a String Is a Valid Sequence | Medium | ⭐ | 有效序列 |
| 1448 | Count Good Nodes in Binary Tree | Medium | ⭐⭐ | 好节点计数 |

### 🔶 二叉搜索树 (Medium-Hard 80题)

#### BST基础操作类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 98 | Validate Binary Search Tree | Medium | ⭐⭐⭐ | BST验证 |
| 700 | Search in a Binary Search Tree | Easy | ⭐⭐ | BST搜索 |
| 701 | Insert into a Binary Search Tree | Medium | ⭐⭐ | BST插入 |
| 450 | Delete Node in a BST | Medium | ⭐⭐⭐ | BST删除 |
| 230 | Kth Smallest Element in a BST | Medium | ⭐⭐⭐ | BST第K小 |
| 285 | Inorder Successor in BST | Medium | ⭐⭐ | BST后继 |
| 510 | Inorder Successor in BST II | Medium | ⭐ | BST后继II |
| 783 | Minimum Distance Between BST Nodes | Easy | ⭐ | BST最小距离 |
| 530 | Minimum Absolute Difference in BST | Easy | ⭐ | BST最小差值 |
| 538 | Convert BST to Greater Tree | Medium | ⭐⭐ | BST转换 |
| 1038 | Binary Search Tree to Greater Sum Tree | Medium | ⭐ | BST求和树 |
| 173 | Binary Search Tree Iterator | Medium | ⭐⭐⭐ | BST迭代器 |
| 99 | Recover Binary Search Tree | Medium | ⭐⭐ | 恢复BST |
| 108 | Convert Sorted Array to Binary Search Tree | Easy | ⭐⭐⭐ | 数组转BST |
| 109 | Convert Sorted List to Binary Search Tree | Medium | ⭐⭐ | 链表转BST |

#### BST进阶操作类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 95 | Unique Binary Search Trees II | Medium | ⭐⭐ | 生成所有BST |
| 96 | Unique Binary Search Trees | Medium | ⭐⭐ | BST个数 |
| 426 | Convert Binary Search Tree to Sorted Doubly Linked List | Medium | ⭐⭐ | BST转链表 |
| 449 | Serialize and Deserialize BST | Medium | ⭐⭐ | BST序列化 |
| 669 | Trim a Binary Search Tree | Medium | ⭐⭐ | 修剪BST |
| 776 | Split BST | Medium | ⭐ | 分割BST |
| 1008 | Construct Binary Search Tree from Preorder | Medium | ⭐ | 前序构造BST |
| 1373 | Maximum Sum BST in Binary Tree | Hard | ⭐ | 最大和BST |
| 1569 | Number of Ways to Reorder Array to Get Same BST | Hard | ⭐ | BST重排序 |
| 1612 | Check If Two Expression Trees are Equivalent | Medium | ⭐ | 表达式树 |

#### 范围查询类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 938 | Range Sum of BST | Easy | ⭐⭐ | BST范围和 |
| 653 | Two Sum IV - Input is a BST | Easy | ⭐⭐ | BST两数和 |
| 1214 | Two Sum BSTs | Medium | ⭐ | 两个BST和 |
| 270 | Closest Binary Search Tree Value | Easy | ⭐⭐ | BST最接近值 |
| 272 | Closest Binary Search Tree Value II | Hard | ⭐ | BST最接近K值 |
| 333 | Largest BST Subtree | Medium | ⭐ | 最大BST子树 |
| 1932 | Merge BSTs to Create Single BST | Hard | ⭐ | 合并BST |
| 1902 | Depth of BST Given Insertion Order | Medium | ⭐ | BST插入深度 |
| 1864 | Minimum Number of Swaps to Make the Binary String Alternating | Medium | ⭐ | 二进制交换 |
| 1586 | Binary Search Tree Iterator II | Medium | ⭐ | BST双向迭代器 |

### 🔴 树的高级算法 (Hard 100题)

#### 最近公共祖先类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 236 | Lowest Common Ancestor of a Binary Tree | Medium | ⭐⭐⭐ | LCA |
| 235 | Lowest Common Ancestor of a Binary Search Tree | Easy | ⭐⭐⭐ | BST LCA |
| 1644 | Lowest Common Ancestor of a Binary Tree II | Medium | ⭐⭐ | LCA II |
| 1650 | Lowest Common Ancestor of a Binary Tree III | Medium | ⭐ | LCA III |
| 1676 | Lowest Common Ancestor of a Binary Tree IV | Medium | ⭐ | LCA IV |
| 1123 | Lowest Common Ancestor of Deepest Leaves | Medium | ⭐ | 最深叶子LCA |
| 865 | Smallest Subtree with all the Deepest Nodes | Medium | ⭐ | 最深节点子树 |
| 1484 | Group Sold Products By The Date | Easy | ⭐ | SQL题目 |
| 1740 | Find Distance in a Binary Tree | Medium | ⭐ | 树中距离 |
| 1257 | Smallest Common Region | Medium | ⭐ | 最小公共区域 |

#### 树的构造与重建类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 105 | Construct Binary Tree from Preorder and Inorder | Medium | ⭐⭐⭐ | 前中序构造 |
| 106 | Construct Binary Tree from Inorder and Postorder | Medium | ⭐⭐⭐ | 中后序构造 |
| 889 | Construct Binary Tree from Preorder and Postorder | Medium | ⭐⭐ | 前后序构造 |
| 297 | Serialize and Deserialize Binary Tree | Hard | ⭐⭐⭐ | 序列化 |
| 449 | Serialize and Deserialize BST | Medium | ⭐⭐ | BST序列化 |
| 428 | Serialize and Deserialize N-ary Tree | Hard | ⭐ | N叉树序列化 |
| 652 | Find Duplicate Subtrees | Medium | ⭐⭐ | 重复子树 |
| 1028 | Recover a Tree From Preorder Traversal | Hard | ⭐ | 恢复树 |
| 1597 | Build Binary Expression Tree From Infix Expression | Hard | ⭐ | 表达式树 |
| 1628 | Design an Expression Tree With Evaluate Function | Medium | ⭐ | 表达式树设计 |

#### 树形DP高级类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 337 | House Robber III | Medium | ⭐⭐ | 树形DP |
| 968 | Binary Tree Cameras | Hard | ⭐⭐ | 树形DP |
| 834 | Sum of Distances in Tree | Hard | ⭐ | 换根DP |
| 979 | Distribute Coins in Binary Tree | Medium | ⭐⭐ | 树形DP |
| 1372 | Longest ZigZag Path in a Binary Tree | Medium | ⭐ | 树形DP |
| 1339 | Maximum Product of Splitted Binary Tree | Medium | ⭐ | 树形DP |
| 1617 | Count Subtrees With Max Distance Between Cities | Hard | ⭐ | 树形DP |
| 1245 | Tree Diameter | Medium | ⭐ | 树直径 |
| 1519 | Number of Nodes in the Sub-Tree With the Same Label | Medium | ⭐ | 换根DP |
| 2049 | Count Nodes With the Highest Score | Medium | ⭐ | 换根DP |

#### 复杂树操作类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 545 | Boundary of Binary Tree | Medium | ⭐ | 树边界 |
| 863 | All Nodes Distance K in Binary Tree | Medium | ⭐⭐ | 距离K节点 |
| 742 | Closest Leaf in a Binary Tree | Medium | ⭐ | 最近叶子 |
| 1162 | As Far from Land as Possible | Medium | ⭐ | BFS |
| 1110 | Delete Nodes And Return Forest | Medium | ⭐ | 删除节点 |
| 1161 | Maximum Level Sum of a Binary Tree | Medium | ⭐ | 最大层和 |
| 1026 | Maximum Difference Between Node and Ancestor | Medium | ⭐ | 最大祖先差 |
| 1038 | Binary Search Tree to Greater Sum Tree | Medium | ⭐ | BST转换 |
| 1104 | Path In Zigzag Labelled Binary Tree | Medium | ⭐ | 锯齿标记树 |
| 1145 | Binary Tree Coloring Game | Medium | ⭐ | 树着色游戏 |

### 🌟 特殊树结构 (Medium-Hard 50题)

#### Trie字典树类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 208 | Implement Trie (Prefix Tree) | Medium | ⭐⭐⭐ | Trie实现 |
| 211 | Design Add and Search Words Data Structure | Medium | ⭐⭐⭐ | Trie应用 |
| 212 | Word Search II | Hard | ⭐⭐⭐ | Trie+DFS |
| 677 | Map Sum Pairs | Medium | ⭐ | Trie求和 |
| 720 | Longest Word in Dictionary | Easy | ⭐ | Trie |
| 648 | Replace Words | Medium | ⭐ | Trie替换 |
| 1268 | Search Suggestions System | Medium | ⭐⭐ | Trie搜索 |
| 421 | Maximum XOR of Two Numbers in an Array | Medium | ⭐⭐ | Trie+位运算 |
| 1707 | Maximum XOR With an Element From Array | Hard | ⭐ | Trie+位运算 |
| 1948 | Delete Duplicate Folders in System | Hard | ⭐ | Trie+DFS |

#### 线段树类
| 题号 | 题目 | 难度 | 频率 | 标签 |
|------|------|------|------|------|
| 307 | Range Sum Query - Mutable | Medium | ⭐⭐ | 线段树 |
| 308 | Range Sum Query 2D - Mutable | Hard | ⭐ | 2D线段树 |
| 315 | Count of Smaller Numbers After Self | Hard | ⭐⭐ | 线段树 |
| 493 | Reverse Pairs | Hard | ⭐⭐ | 线段树 |
| 218 | The Skyline Problem | Hard | ⭐⭐ | 线段树 |
| 699 | Falling Squares | Hard | ⭐ | 线段树 |
| 715 | Range Module | Hard | ⭐ | 线段树 |
| 732 | My Calendar III | Hard | ⭐ | 线段树 |
| 850 | Rectangle Area II | Hard | ⭐ | 线段树 |
| 1044 | Longest Duplicate Substring | Hard | ⭐⭐ | 后缀数组 |

## 🎯 重点题目推荐

### 🔥 面试必备 (Top 30)
| 难度 | 题目 | 重要性 | 考察频率 |
|------|------|---------|----------|
| Easy | 104. Maximum Depth of Binary Tree | ⭐⭐⭐⭐⭐ | 极高 |
| Easy | 226. Invert Binary Tree | ⭐⭐⭐⭐⭐ | 极高 |
| Easy | 101. Symmetric Tree | ⭐⭐⭐⭐ | 很高 |
| Medium | 102. Binary Tree Level Order Traversal | ⭐⭐⭐⭐⭐ | 极高 |
| Medium | 98. Validate Binary Search Tree | ⭐⭐⭐⭐⭐ | 极高 |
| Medium | 230. Kth Smallest Element in a BST | ⭐⭐⭐⭐ | 很高 |
| Medium | 236. Lowest Common Ancestor | ⭐⭐⭐⭐⭐ | 极高 |
| Hard | 124. Binary Tree Maximum Path Sum | ⭐⭐⭐⭐⭐ | 极高 |
| Hard | 297. Serialize and Deserialize Binary Tree | ⭐⭐⭐⭐ | 很高 |
| Medium | 105. Construct Binary Tree from Preorder and Inorder | ⭐⭐⭐⭐ | 很高 |

### 🏢 公司偏好题目

#### 🟦 Facebook/Meta
- 104. Maximum Depth of Binary Tree
- 226. Invert Binary Tree
- 102. Binary Tree Level Order Traversal
- 236. Lowest Common Ancestor
- 124. Binary Tree Maximum Path Sum

#### 🟨 Google
- 98. Validate Binary Search Tree
- 297. Serialize and Deserialize Binary Tree
- 230. Kth Smallest Element in a BST
- 212. Word Search II
- 208. Implement Trie

#### 🟧 Amazon
- 102. Binary Tree Level Order Traversal
- 101. Symmetric Tree
- 112. Path Sum
- 199. Binary Tree Right Side View
- 863. All Nodes Distance K

#### ⬛ Apple
- 104. Maximum Depth of Binary Tree
- 226. Invert Binary Tree
- 98. Validate Binary Search Tree
- 105. Construct Binary Tree
- 236. Lowest Common Ancestor

#### 🟩 Microsoft
- 102. Binary Tree Level Order Traversal
- 98. Validate Binary Search Tree
- 104. Maximum Depth of Binary Tree
- 230. Kth Smallest Element in a BST
- 173. Binary Search Tree Iterator

## 📝 学习建议

### 🎯 刷题顺序
1. **基础阶段**: 树的遍历和基本性质 (104, 226, 101, 100)
2. **进阶阶段**: BST操作和LCA (98, 230, 236, 235)
3. **提高阶段**: 树的构造和路径问题 (105, 106, 112, 124)
4. **高级阶段**: 树形DP和特殊树结构 (337, 208, 307)

### 💡 核心技巧
1. **递归思维**: 大部分树问题都可以用递归解决
2. **分治思想**: 左右子树分别处理后合并
3. **DFS/BFS**: 掌握深度优先和广度优先遍历
4. **状态传递**: 在递归中传递必要的状态信息

### ⚡ 时间复杂度分析
- **遍历**: O(n) - 访问每个节点一次
- **搜索**: O(logn) 平均 / O(n) 最坏 - BST操作
- **构造**: O(n) - 需要处理所有节点
- **路径**: O(n) - 可能需要访问所有路径

### 🎨 经典树算法模板

#### DFS遍历模板
```cpp
void dfs(TreeNode* root) {
    if (!root) return;
    
    // 前序位置
    dfs(root->left);
    // 中序位置
    dfs(root->right);
    // 后序位置
}
```

#### BFS遍历模板
```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    if (!root) return {};
    
    vector<vector<int>> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int size = q.size();
        vector<int> level;
        
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(level);
    }
    
    return result;
}
```

#### 树形DP模板
```cpp
pair<int, int> dfs(TreeNode* root) {
    if (!root) return {0, 0};
    
    auto left = dfs(root->left);
    auto right = dfs(root->right);
    
    // 选择当前节点的情况
    int include = root->val + left.second + right.second;
    // 不选择当前节点的情况
    int exclude = max(left.first, left.second) + max(right.first, right.second);
    
    return {include, exclude};
}
```

**树是最重要的数据结构之一，掌握树的各种操作是算法基础！** 🌳🚀
